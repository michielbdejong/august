<!-- minimal branch systems -->
<p>As a hobby, I try to understand why computation takes time. In mechanical physics, time is related to space, mass, and (kinetic) energy: travel takes time. But computation does not involve travel. It involves iterative logical steps, but these can often be collapsed into a single step by rewriting a formula. It is therefore not at all clear why (in the metaphysics sense) computation takes time.</p>
<p>This is a brainstorm with some sparsely related concepts that may help to talk about the relationship between computation and time.</p>

<h2>Branch systems</h2>
<p>A branch system is one of:</p>
<ul>
  <li>a variable x_i (for integer i)</li>
  <li>false</li>
  <li>true</li>
  <li>an expression <code>if (a) then (b) else (c)</code> (for a, b, c branch systems)</li>
</ul>

Here, false and true are the familiar atomic Boolean expressions that are always false or always true, respectively, and the variables represent inputs
of the expression. The meaning of the ternary if-then-else operator is defined as <code>((a AND b) OR (NOT(a) AND c))</code>; in a truth table (0=false, 1=true):

<table><tr><td>x_1</td><td>x_2</td><td>x_3</td><td>if (x_1) then (x_2) else (x3)</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>1</td></tr>
</table>

Intuitively, it takes on the value of x_2 if x_1 is true, and that of x_3 otherwise. A NAND port <code>(x_1 NAND x_2)</code> can be expressed as the branch system <code>if(x_1) then (if (x_2) then (false) else (true)) else (true)</code>

Lemma: We can write any Boolean expression as a branch system
Proof: Any Boolean expression can be expressed using only the NAND operator [ref: ?]. Each NAND operator <code>(x_1 NAND x_2)</code> in this expression can then be replaced by two if-then-else operators <code>if(x_1) then (if (x_2) then (false) else (true)) else (true)</code>. The following truth table confirms that this will lead to the same outcome for all four combinations of possible values of x_1 and x_2. Defining A as the subexpression <code>if (x_2) then (false) else (true)</code>,

<table><tr><td>x_1</td><td>x_2</td><td>if (x_2) then (false) else (true) - "A"</td><td>if(x_1) then (A) else (true)</td><td>(x1 NAND x2)</td></tr>
<tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
</table>

QED.

<h2>Minimal finite branch systems</h2>
<p>I'm defining the size of a branch system as the number of if-then-else operators it contains (occurences of true, false, and variables come for free and don't count towards the system's size). Now we can ask what the minimum size is of a branch system that is equivalent to a given Boolean expression. Here are all branch systems of size 1, and the Boolean expression they compute. Variations by switching around the variable names are omitted; only the variations in which variables are numbered x_1, x_2, x_3 in order of appearance are shown:

<table><tr><td>branch system</td><td>expression</td></tr>
<tr><td>if (false) then (false) else (false)</td><td>false</td></tr>
<tr><td>if (false) then (false) else (true)</td><td>true</td></tr>
<tr><td>if (false) then (false) else (x_1)</td><td>x_1</td></tr>
<tr><td>if (false) then (true) else (false)</td><td>false</td></tr>
<tr><td>if (false) then (true) else (true)</td><td>true</td></tr>
<tr><td>if (false) then (true) else (x_1)</td><td>x_1</td></tr>
<tr><td>if (false) then (x_1) else (false)</td><td>false</td></tr>
<tr><td>if (false) then (x_1) else (true)</td><td>true</td></tr>
<tr><td>if (false) then (x_1) else (x_1)</td><td>x_1</td></tr>
<tr><td>if (false) then (x_1) else (x_2)</td><td>x_2</td></tr>
<tr><td>if (true) then (false) else (false)</td><td>false</td></tr>
<tr><td>if (true) then (false) else (true)</td><td>false</td></tr>
<tr><td>if (true) then (false) else (x_1)</td><td>false</td></tr>
<tr><td>if (true) then (true) else (false)</td><td>true</td></tr>
<tr><td>if (true) then (true) else (true)</td><td>true</td></tr>
<tr><td>if (true) then (true) else (x_1)</td><td>true</td></tr>
<tr><td>if (true) then (x_1) else (false)</td><td>x_1</td></tr>
<tr><td>if (true) then (x_1) else (true)</td><td>x_1</td></tr>
<tr><td>if (true) then (x_1) else (x_1)</td><td>x_1</td></tr>
<tr><td>if (true) then (x_1) else (x_2)</td><td>x_1</td></tr>
<tr><td>if (x_1) then (false) else (false)</td><td>false</td></tr>
<tr><td>if (x_1) then (false) else (true)</td><td>NOT(x_1)</td></tr>
<tr><td>if (x_1) then (false) else (x_1)</td><td>false</td></tr>
<tr><td>if (x_1) then (false) else (x_2)</td><td>(NOT(x_1) AND x_2)</td></tr>
<tr><td>if (x_1) then (true) else (false)</td><td>x_1</td></tr>
<tr><td>if (x_1) then (true) else (true)</td><td>true</td></tr>
<tr><td>if (x_1) then (true) else (x_1)</td><td>x_1</td></tr>
<tr><td>if (x_1) then (true) else (x_2)</td><td>(x_1 OR x_2)</td></tr>
<tr><td>if (x_1) then (x_1) else (false)</td><td>x_1</td></tr>
<tr><td>if (x_1) then (x_2) else (false)</td><td>(x_1 AND x_2)</td></tr>
<tr><td>if (x_1) then (x_1) else (true)</td><td>true</td></tr>
<tr><td>if (x_1) then (x_2) else (true)</td><td>(NOT(x_1) OR x_2)</td></tr>
<tr><td>if (x_1) then (x_1) else (x_1)</td><td>x_1</td></tr>
<tr><td>if (x_1) then (x_2) else (x_1)</td><td>(x_1 AND x_2)</td></tr>
<tr><td>if (x_1) then (x_1) else (x_2)</td><td>(x_1 OR x_2)</td></tr>
<tr><td>if (x_1) then (x_2) else (x_3)</td><td>((x_1 AND x_2) OR (NOT(x_1) AND x_3))</td></tr>
</table>

And here are some minimal expression sizes for Boolean functions in two variables:

0000 0 false
0001 1 x1 ? x2 : false
0010 1 x2 ? false : x1
0011 0 x1
0100 1 x1 ? false : x2
0101 0 x2
0110 1 x1 ? !x2 : x2
0111 1 x1 ? true : x2
1000 1 x1 ? false : !x2
1001 1 x1 ? x2 : !x2
1010 1 !x2
1011 1 x1 ? true : !x2
1100 0 !x1
1101 1 x1 ? x2 : true
1110 1 x1 ? !x2 : true
1111 0 true

In three variables, there are already 256 Boolean functions, so let's write a program to enumerate minimal branch systems for them.

<h2>Finite problems</h2>
<p>Traditionally, theoretical computer science talks about problems whose instances have unlimited size, and which are solved by computers with infinite memory space. Here, I want to look at finite computers solving finite problems. In particular, branch systems calculating Boolean functions, like the ones above. A program that solves a problem only for instances of one given input length is still interesting - even if you don't have a generic 3-SAT solver, one that works for an input size of 100 clauses would still be a powerful tool in practice. Especially if you fill up real-world problems that have, say, 87 clauses with tautological clauses to turn them into 100-clause problems this solver understands, then for all practical intents and purposes, you can say you have a 3-SAT solver.</p>
<p>And the nice thing about those finite computers is that we can write them as branch systems expressions, and prove things about their optimality by counting the number of operators in them. This is much more concise than counting the number of steps needed by a Turing machine to halt, since there are way fewer concepts involved. The if-then-else operators are related closely to the structure of the solution space.</p>

<p>Computation takes time because no finite circuit exists that computes that same finite function with less operators.</p>

x1 ? (x2 ? (x3 ? true : false) : (x3 ? true : false)) : (x2 ? (x3 ? true : false) : (x3 ? true : false))

- full tree x1 -> x2 -> x3
- full tree x1 -> x3 -> x2
- full tree x2 -> x1 -> x3
- full tree x2 -> x3 -> x1
- full tree x3 -> x1 -> x2
- full tree x3 -> x2 -> x1

number of 1's: 0 - 8
01101001 x1 ? (x2 ? x3 : !x3) : (x2 ? !x3 : x3)

reducables:
* true ? a : b -> a
* false ? a : b -> b
* a ? true : false -> a
* xi ? false : true -> !xi
* a ? b : b -> b
* a ? (b ? c : d) : (e ? c : d) -> (a ? b : e) ? c : d [puts (c : d) on the stack while (a ? b : e) is being calculated. this requires memory]
* a ? (b ? c : d) : (b ? e : f) == b ? (a ? c : e) : (a ? d : f) [shall we call this a rotation?]

thanks to these reducables, you'll never see true or false as the first ("if") argument, etc.

00000000 0 false
00000001 1 x1 ? (x2 ? x3 : false) : false
00000010 1 x1 ? (x3 ? false : x2) : false
00000011 0 x1 ? (x2) : false
00000100 1 x1 ? (x2 ? false : x3) : false
00000101 0 x1 ? (x3) : false
00000110 1 x1 ? (x2 ? !x3 : x3) : false
00000111 1 x1 ? (x2 ? true : x3) : false
00001000 1 x1 ? (x2 ? false : !x3) : false
00001001 1 x1 ? (x2 ? x3 : !x3) : false
00001010 1 x1 ? (!x3) : false
00001011 1 x1 ? (x2 ? true : !x3) : false
00001100 0 x1 ? (!x2) : false
00001101 1 x1 ? (x2 ? x3 : true) : false
00001110 1 x1 ? (x2 ? !x3 : true) : false
00001111 0 x1
00010000 0 x1 ? false : (x2 ? x3 : false)
00010001 1 x1 ? (x2 ? x3 : false) : (x2 ? x3 : false)
00010010 1 x1 ? (x3 ? false : x2) : (x2 ? x3 : false)
00010011 0 x1 ? (x2) : (x2 ? x3 : false)
00010100 1 x1 ? (x2 ? false : x3) : (x2 ? x3 : false)
00010101 0 x1 ? (x3) : (x2 ? x3 : false)
00010110 1 x1 ? (x2 ? !x3 : x3) : (x2 ? x3 : false)
00010111 1 x1 ? (x2 ? true : x3) : (x2 ? x3 : false)
00011000 1 x1 ? (x2 ? false : !x3) : (x2 ? x3 : false)
00011001 1 x1 ? (x2 ? x3 : !x3) : (x2 ? x3 : false)
00011010 1 x1 ? (!x3) : (x2 ? x3 : false)
00011011 1 x1 ? (x2 ? true : !x3) : (x2 ? x3 : false)
00011100 0 x1 ? (!x2) : (x2 ? x3 : false)
00011101 1 x1 ? (x2 ? x3 : true) : (x2 ? x3 : false)
00011110 1 x1 ? (x2 ? !x3 : true) : (x2 ? x3 : false) -> x3 ? (x1 ? !x2 : x2) : x2) -> x2 ? 0110 : 0011
00011111 0 x1 ? true : (x2 ? x3 : false)

when branching on a complex function, you're reusing code compared to writing out all the paths the computation can take. the number of nodes in the tree becomes less, but the number of sequential computation steps stays the same. for simplicity (not to have to deal with call stacks), let's make branching on a variable the normal form (even if it leads to repeated subtrees in some cases).

that makes reduction easy. there are basically 3 options:
00011110 =
* x1 ? 1110 : 0001
* x2 ? 0110 : 0011
* x3 ? 0110 : 0011

then we only have to calculate the cost of
1110 =
* x1 ? !x2 : true
* x2 ? !x1 : true

0001 =
* x1 ? x2 : false
* x2 ? x1 : false

0110 =
* x1 ? !x2 : x2
* x2 ? !x1 : x1

0011 = x1

so cost is 3 when starting with x1, e.g.:
    x1 ? (x1 ? !x2 : true) : (x1 ? x2 : false)
or 2 when starting with x2 or x3, e.g.:
    x2 ? (x1 ? !x3 : x3) : x1

<script>
function Truthtable(str) {
  var i, nodes = [];
  for (i=0; i<str.length; i++) {
    nodes.push(str[i] === '1');
  }
  this.reduce(nodes);
}

Truthtable.prototype.reduce = function(nodes) {
  var i, reduced;
  if (nodes.length === 1) {
    this.tree = nodes;
  } else {
    reduced = [];
    for (i=0; i<nodes.length; i+=2) {
      reduced.push([nodes[i], nodes[i+1]]);
    }
    this.reduce(reduced);
  }
}
</script>